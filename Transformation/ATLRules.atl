-- @path MMUS=/US2XPDL/MetaModels/My.ecore
-- @path MMXPDL=/US2XPDL/MetaModels/XPDL.ecore

module ATLRules;
create OUT : MMXPDL from IN : MMUS;

rule ActivitieslieeToProcess{
	from 
		act:MMUS!Activity
		
	to	
		
		actx : MMXPDL!Activity(
			id <-'1',
			name <- 'test'
		),
	
		ws: MMXPDL!WorkflowProcess(
				name <- 'P1',
				activityxpdl <- actx
			)
					

}


rule FirstRulTransformation{
	from 
		us: MMUS!UserStory
		
	to
	
	
   		ws : MMXPDL!Activity(
			id <- MMUS!UserStory.allInstances() -> select(e| e.roles.name = us.roles.name) -> collect(e | e.activities.id),-- -> asSequence()
			name <- MMUS!UserStory.allInstances() -> select(e| e.roles.name = us.roles.name) -> collect(e | e.activities.name)  
		),	
		wps: MMXPDL!WorkflowProcess(
				name <- 'P1',
				activityxpdl <- ws
			)
}
		
		
rule FirstRuleTransformation{
	from 
		bg: MMUS!Backlog
		
	to
	
		--ws: MMXPDL!Activity(
		 --id <- bg.getActivitiesFromBG('student') Sequence {IN!pass exam, IN!activity student}
		 --id <- us.getActivites()
		-- setActivitiesProcess(Process:MMXPDL!Workflowprocess, activities : Set(MMXPDL!Activity))
		--)
		
		ws: MMXPDL!WorkflowProcess(
			name <- 'P1',
			activityxpdl <- bg.getActivitiesFromBG('student')
			)

		
	
	
--	upposons que activity est atribu f process f xpdl et aussi role
--		ws: MMXPL!WorkflowProcess(
--				role <- 'student'
--				activity <- us.getActivities('student')
--			)
--	ws : MMXPD!Activity(
		--		id <- 1
   --	 name <- us.getActivities('student').get(1)  
		--	)

			
		
		
		

    do{
        --bg.getActivitesByRole(); 
       --bg.getActivitiesFromBG('student').println();
       --us.getActivitiesFromUS('student').at(2).id.println(); --getKey()
       --getActivitiesFromUS('student').at(2).name.println();
        'hiba'.println(); 
    }
			
}
-----------Fin Rule 1----------------
----------Rule 2----------

-----------Fin Rule 2----------------

---------Helper------------role : MMUS!UserStory.Role Set(self.Activity) 
helper context MMUS!UserStory def : getActivities(role : String) : Set(Sequence(String)) = --Set(MMUS!Activity)
--if 'stdent'=role then
if self.roles.name = role then
 MMUS!UserStory.allInstances() -> collect(e | e.activities.name) ->	
 --self.userstory->collect(e | e.activity)->
 asSet()->
 iterate(activity; list : Set(Sequence(String)) =  Sequence{}  |list.including(activity))
 --- code number 3
else self.roles.name
endif;


helper context MMUS!UserStory def : getActivitiesFromUS(role : String) : Sequence(MMUS!Activity)=
--if 'stdent'=role then
--if self.roles.name = role then
 MMUS!UserStory.allInstances() ->	select(e| e.roles.name = role) -> collect(e | e.activities) -> asSequence();
 --asSet();
 -- -> iterate(activity; list : Set(MMUS!Activity) =  Sequence{}  |list.including(activity));

--else ''
--endif;
helper context MMUS!Backlog def : getActivitiesFromBG(role : String) : Sequence(MMUS!Activity)=

 self.uss ->	select(e| e.roles.name = role) -> collect(e | e.activities) -> asSequence();



helper context MMUS!Backlog def : getActivitiesFromBGL(role : String) : Sequence(MMXPDL!Activity)= 
self.uss ->	select(e| e.roles.name = role) -> collect(e | e.activities) -> asSequence() ;
-- ->iterate(activity; list : Sequence(MMXPDL!Activity) =  Sequence{}  |list.including(MMXPDL!Activity(id<-'1',name<-'tst')));





helper context MMUS!UserStory def:getActivitesByRole():Integer = MMUS!UserStory.allInstances() -> collect(us| us.id);

helper context MMUS!UserStory def:getActivit():Integer = MMUS!UserStory.allInstances()-> iterate(e; sum : Integer = 0 |
	sum +e
);




